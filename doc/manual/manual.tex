%% =======================================================
%% (c) 2018 Tobias Schoofs
%% =======================================================
%% NowDB
%% =======================================================

% Plain Style
\documentclass{scrreprt}

\include{cmds}

\usepackage{authblk}
\usepackage[toc,page]{appendix}
\usepackage{url}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{nicefrac}

\begin{document}
\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt}

\title {NoWDB}
\author {tobias.schoofs@gmx.net}
\date{\today}
%\includegraphics[scale=0.75]{sonic.jpg}\\[24pt]\today}
\maketitle
\tableofcontents

\chapter{Introduction}\label{chpt_intro} 
\nowdb\ is a kind of database.
It merges the concepts
of \term{graph} and \term{timeseries} database.
Timeseries databases typically have simple
data models centred around timelines
consisting of pairs of the form
$(timestamp,value)$
with additional $tags$ to
distinguish thematically different timelines.
An example may be a weather forecast
application with timelines describing
temperature, humidity and air pressure
at certain locations. The values would
reflect these measurements and timestamps
would refer to the points in time when
the measurements were taken. Tags would
be used to distinguish timelines
(temperature, humidity, pressure) and
to identify the location from where the
respective measurement comes.

Graph databases replace the set-theoretic
fundaments of relational databases by
graph theory. Graph databases do not deal
with relations over sets, but with
sets of vertices that are connected
by edges. In Twitter-like applications,
vertices may represent users.
The connections between users such as
\term{following} could then be expressed
in terms of edges between vertices.
Applications built on top of graph databases
typically focus on finding relations
between vertices; a goal may be to decide
whether a user $A$ belongs to the network
of a user $B$ where a follower of a
follower of $B$ is considered part of
$B$'s network. Another challenge may be
to compute how many users have seen
a certain tweet or how many users
see tweets of user $A$ in general.

While timeseries databases stress
fast processing of large volumes of
data with similar and, typically, simple structure,
graph databases focus on efficiently handling
data with growing complexity.

\nowdb\ aims to provide the
performance advantages of timeseries databases
using concepts from graph databases
to allow more complex data models
than usually seen with timeseries databases.
\nowdb\ can thus be applied to a wider
range of applications than pure
timeseries databases without losing
their performance advantage.

\nowdb\ is in particular strong with
data that can be organised in some variant of the
\term{star schema}. Relations between
fact tables and dimensional tables
are expressed in terms of
weighted and timestamped edges
between dimensional data that
are represented as complex vertices.
In contrast to traditional
\term{star schema} applications,
\nowdb\ is not limited to data analysis.
Many features stress real-time data
processing providing \term{publish and subscribe},
online data filtering and integration with big-data
infrastructure.

\newpage
This manual documents the main features
of the database and discusses important
use cases. The next chapter provides
a \term{Quick Start} tutorial that helps
understanding the concepts behind \nowdb\
and introduces the most important tools.
The chapter will close
with an overview of the remaining
chapters of this document.

\comment{
Throughout the document, the reader will encounter
red comments like this one.
These comments aim to clarify the current state
of the prototype. They, in particular, draw
attention to features that are not yet available
or to shortcomings of their current implementation.
This way, the manual also serves as an agenda
for the months to come. The goal is indeed
to get rid of all those comments. When the last
red line has gone, \nowdb\ is ready for the first
release.
}

\chapter{Quick Start}\label{chpt_quickst}
\input{quick}

\chapter{SQL}\label{chpt_sql}
\input{sql}

\chapter{Data Modelling}\label{chpt_model}
\comment{
stress differences between graph and relational\\
what is good design / best practice for both:
timeseries and graph \\
examples:
wmo (pure timeseries),
retail (timeseries + graph)
}

\chapter{The NoWDB daemon}\label{chpt_nowdbd}
\comment{tbc}

\chapter{The Client Tool}\label{chpt_clienttool}
\comment{tbc}

\chapter{Higher Level C and C++ Client}\label{chpt_ccpp}
\comment{tbd}

\chapter{Python Client}\label{chpt_pythonclient}
\input{pyclient}

\chapter{Go Client}\label{chpt_goclient}
\comment{tbd}

\chapter{Lua Client}\label{chpt_luaclient}
\comment{tbd}

\chapter{The Low-Level C Client}\label{chpt_llc}
\input{lowc}

\chapter{Embedded Python}\label{chpt_pythonemb}
\input{pyemb}

\chapter{Embedded Lua}\label{chpt_luaemb}
\comment{tbd}

\chapter{Detailed Installation Guide}\label{chpt_install}
\comment{tbd}

\chapter{Defining Data Loaders}\label{chpt_loader}
\comment{tbd}

\chapter{Pub/Sub and Filters}\label{chpt_pubsub}
\comment{tbd}

\chapter{Optimising Queries}\label{chpt_opt}
\input{qopt}

\chapter{Table and Index Sizing}\label{chpt_sizing}
\comment{tbc}

\chapter{Error Codes}\label{chpt_errors}
\input{errors}

\end{document}
