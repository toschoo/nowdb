\section{Outline}
\sql\ is a language to store, manipulate
and query data in a database; traditionally
\sql\ is used with relational databases.
In recent years, however, people have
started to use \sql\ also in other context,
such as \term{graph} and \term{timeseries}
databases and new patterns are evolving
in the language to better address those
data models.

\sql\ consists of statements that,
in their turn, consist of clauses.
A statement is a piece of \sql\ code
that by itself constitutes a meaningful
action in the database. Statements are
distinguished in

\begin{itemize}
\item \acronym{ddl}:
Statements that manipulate entities
in the database that hold or define
data
like tables, types, edges, indices,
functions or procedures.

\item \acronym{dml}:
Statements that manipulate data,
\eg\ \term{insert}, \term{update} and
\term{delete}.

\item \acronym{dll}:
Statements that load large volumes of data into the database
or retrieve large volumes of data from the database.

\item \acronym{dql}:
Statements that read data from the database.

\item Miscellaneous:
Statements that do not fall into any
those categories, in particular
\term{use} and \term{exec}.
\end{itemize}

Clauses are parts of statements;
a \acronym{dql} statement, for instance,
typically has a \term{select} clause and
a \term{from} clause and may have
additional clauses (\term{where},
\term{order by}, \etc).

Some clauses can appear in more than
one type of statement. \term{update}
and \term{delete} statements, typically,
have a \term{where} clause, but no
\term{select} clause.

Clauses can be seen as logical building blocks
of \sql. But they cannot live alone.
It is not possible to execute an isolated \term{where}
clause or an isolated \term{from} clause.
The smallest executable unit is therefore the statement.

Clauses are made of keywords, identifiers, numbers
and text strings. Keywords and identifiers are mutually
exclusive, that is, if $k$ is a keyword,
it cannot be an identifier.
\comment{This rule is relaxed in most
\sql\ dialects -- and that makes a lot of sense,
because \sql\ has an extraordinary large
number of keywords which sometimes makes the choice
of meaningful identifiers a non-trivial task.
At the time of writing, the \nowdb\ parser
does not relax this rule, but it will do so
in the future.}
Keywords are defined by the language,
identifiers are chosen by the user
and refer to entities in the database,
such as tables, types, indices, \etc\

In this specification,
keywords are typeset in boldface
(\eg\ \keyword{table});
identifiers are typeset in italics
(like `mytable' in 
``\keyword{create table} \identifier{mytable}'').

\sql\ is a textual interface.
All statements that are passed to the database
have a textual form. The results produced
by the database, however, are not. They are
binary data which may or may not
contain textual parts.

In \nowdb\ \sql\ statements are strings
of \acronym{utf}-8 characters.
Keywords, identifiers and numbers, however,
must contain only characters
from the \acronym{ascii} subset.
Text, by contrast, may contain any
\acronym{utf}-8 character.
\comment{It is already possible to store
\acronym{utf}-8 in the database.
But comparison and sorting are not yet
\acronym{utf}-compliant. This is an
urgent to-do.}

Keywords and identifiers are case-insensitive.
There is no difference in
\term{SELECT}, \term{select} or \term{Select}
and so on.
Text, by contrast, is case-sensitive;
\term{'hello world'} and \term{hello World}
are not the same!

\sql\ is a \term{guest} language
that needs some kind of framework
to support it. One way to provide this
framework is the \nowdb\ client,
which provides two means to execute
\sql\ \term{statements} in the database,
\ie\ by means of the \tech{-Q} parameter
and by means of standard input.

Another way is a guest language
that provides means to pass \sql\ statements
to the database and means to receive
and interpret the results produced by such statements.

The protocol that defines how data are exchanged
between the database and the host system
is not part of this specification.
Currently, native client and server libraries
exist that implement this protocol
without exposing it to the user.
To support open standards in the future, such as
\acronym{odbc} and \acronym{jdbc},
parts of this protocol must be documented
and published.

\section{Types}
\subsection{Static Types}
The static types constitute the \nowdb\ \sql\ type system.
The static types can be used in \sql\ statements.
The declaration form is used in \acronym{ddl} statements
to define types, edges, procedure and functions.
In \acronym{dml}, \acronym{dll} and \acronym{dql} statements,
instances of the types are used, \ie\
types are not explicitly declared, but used implicitly
by means of their constructors, which are sufficient
to determine the type uniquely.

In the case of numeric types
(integers, unsigned integers and floats),
\nowdb\ silently corrects type mismatches where possible.
An unsigned integer inserted into a field where
a signed integer is expected, is implicitly converted
to an integer; correspondingly a signed integer
is converted to an unsigned integer if possible.
If the unsigned integer is out of range or
the signed integer is negative, the statement
is rejected with a type error.
Likewise, signed or unsigned integers are converted to floats
if necessary (and possible) and a float might be converted
to an integer (or unsigned integer) if it actually
represents an integer.

\begin{minipage}{\textwidth}
\textbf{Integer}\\
Declaration: $int$, $integer$ \\
Values: $-2^{63} \dots 2^{63}-1$ \\
Constructors: $\pm n$, where $n$ is an unsigned integer.\\
Null: $+0$ \\
Examples: $-1, +0, +1$
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Unsigned Integer} \\
Declaration: $uint$, $uinteger$ \\
Values: $0 \dots 2^{64}-1$  \\
Constructors: One digit from the range $0\dots 9$
or one digit from range $1\dots 9$ followed by
a sequence of digits ($0\dots9$). \\
Null: $0$ \\
Examples: $0, 1, 2, 1024$, but not: $01$.
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Float} \\
Declaration: $float$ \\
Represents a \term{binary64} \acronym{ieee}-754 floating point number.
For possible values, please refer to the standard or to the table in
\url{https://en.wikipedia.org/wiki/IEEE\_754#Basic\_and\_interchange\_formats}.\\
Constructors: any integer followed by a dot and a sequence of digits,
              optionally followed by $e$ followed by an integer.
              \comment{The exponential form is not yet available.} \\
Null: $0.0$ \\
Examples: $-1.0, 0.0, 1.0, 3.14159, 1.797693e308$ 
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Time} \\
Declaration: $time$, $date$ \\
Values:  \acronym{utc} 1677-09-21T00:12:44 --
         \acronym{utc} 2262-04-11T23:47:16 \\
Precision: nanosecond. \\
Note, however, that range and precision depend on server configuration.
With less precision, a higher range can be reached.
Please refer to the database configuration guide. \\
Timezone: \acronym{utc} \\
Constructor: any integer or any string following \acronym{iso}-8601 
or any string following a locally defined time format. \\
Null: $0$ \\
\comment{It should be possible to perform arithmetic
with time units and timestamps
in \sql, \eg: \\
\term{where timestamp = today + 7*day}.\\
That is, why a null type makes sense for time.
Currently, arithmetic with time is not possible in \sql.
(It is possible with the date and time types in host languages, though,
and therefore not urgent.)} \\
Examples:\\
1535284617906179393, \\
'1940-12-21', \\
'1904-06-16T11:43:10', \\
'2011-11-11T11:11:11.123456789'
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Bool} \\
Declaration: $bool$ \\
Values: $true$, $false$ \\
Null: $false$
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Text} \\
Declaration: $text$ \\
Values: \acronym{utf}-8 string with up to 255 bytes\\
Constructor: string enclosed by ' \\
Null: '' (the empty string),\\
Examples:\\
'hello world',\\
\begin{CJK}{UTF8}{gbsn}
'鎮州臨濟慧照禪師語錄序。' 
\end{CJK} \\
\comment{An important detail is not yet handled:
text that \emph{contains} the character '.
This is important for recursive \sql, \eg\ \\
\term{exec metaquery('select * from myedge 
       where a = $\backslash$'some text$\backslash$'')}}
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Longtext} \\
Declaration: text \\
Values: \acronym{utf}-8 string with up to 4096 bytes\\
\comment{Longtext is not yet available.}
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Blob} \\
\comment{Blob is nice to have, but there are currently
no concrete plans to add such a datatype.}
\end{minipage}

\subsection{Dynamic Types}
Dynamic types are not used in \sql\ statements,
but rather describe the return values of \sql\
statements. As such, they live in the context
of a host language (C, Python, Lua, \etc).
There concrete implementation, therefore,
depends on that language and any language
functioning as either client or server-side language
needs to implement these types.
For more information on concrete implementation
of dynamic types, please refer to the
host language \acronym{api} specifications.

\begin{minipage}{\textwidth}
\textbf{Status}\\
Values: \acronym{ok}, \acronym{nok}\\
In the case of error (\acronym{nok}), \nowdb\ provides:
\begin{itemize}
\item an error code
\item a detailed error message
\end{itemize}
Error codes together with a brief description
of their meaning can be found in \ref{chpt_errors}.
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Report}\\
Reports consist of up to three values:
\begin{itemize}
\item number of affected rows
(returned by all \acronym{dml} and \acronym{dll} statements)
\item number of errors
(returned only by \acronym{dll} statements)
\item running time
(returned by most \acronym{dml} and \acronym{dll} statements)
\end{itemize}
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Row}\\
A row is the result of a projection;
it consists of an array of values
with type information called \term{fields}.
In the host language, one would access a field
typically by an expression of the form:
$row.field(i);$
which would return a tuple $(value,type)$.

A row result consists of one or many rows.
The host language shall provide means
to iterate over rows.
\end{minipage}

\begin{minipage}{\textwidth}
\textbf{Cursor}\\
A cursor is an iterable collection of rows.
The iteration directive is \term{fetch}.
Each fetch may return one or many rows.
A cursor is a server-side resource
and shall be closed using the directive \term{close}.
\end{minipage}

\section{Data Definition}
\comment{Due to some time pressure in producing this document,
there are no syntax diagrams, which would make things much
clearer. Instead, examples are given. Examples are easier
to understand quickly, but they are much less precise.}

\comment{For almost all \acronym{ddl} subtypes,
\term{alter} is not yet implemented.}

\subsection{Schema}
The keywords
\term{schema}, \term{database} and \term{scope}
are interchangeable.

\subsubsection{CREATE}
The \term{create schema} statement
creates an empty database physically on disk.
It has the following form:

\keyword{create schema} \identifier{mydb}

This would create all objects necessary
to manage that database.

The following forms are equivalent:

\keyword{create database} \identifier{mydb}\\
\keyword{create scope} \identifier{mydb}

All \keyword{create} clauses can be combined
with the clause \keyword{if not exists}, \eg:

\keyword{create schema} \identifier{mydb} \keyword{if not exists}

The \keyword{if not exists}-clause
suppresses the `duplicate key' error
in case the schema
already exists.
It is a convenient way to avoid
that a \sql\ script is abandoned
in such a situation.

\subsubsection{DROP}
The \term{drop schema} statement
removes a database physically from disk.
It has one of the following forms,
which are all equivalent:

\keyword{drop schema} \identifier{mydb}\\
\keyword{drop database} \identifier{mydb}\\
\keyword{drop scope} \identifier{mydb}

The statement removes all objects and data
belonging to the database `mydb' from disk.

All \keyword{drop} clauses can be combined
with the clause \keyword{if exists}, \eg:

\keyword{drop schema} \identifier{mydb} \keyword{if exists}

The \keyword{if exists}-clause
suppresses the `key not found' error
in case the schema
does not exist.
It is a convenient way to avoid
that a \sql\ script is abandoned
in such a situation.

\subsubsection{ALTER}

\subsection{Table}
\subsubsection{CREATE}
The \term{create table} statement
creates a new storage entity for edges
physically on disk.

The simplest form is:

\keyword{create table} \identifier{mytable}

The keyword table may be decorated
with a sizing option:

\keyword{create big table} \identifier{mytable}

Valid sizing keywords are:
\keyword{tiny, small, medium, big, large, huge}.

Sizing keywords affect the allocation units
of disk space. The concrete meaning is not
part of this specification and may change
in the future.

It is also possible to add options to
to a \term{create table} statement.
Options have the general form

\term{\keyword{set} option = value, option = value}.

Valid options and values are listed in the following table:

\bgroup
\renewcommand{\arraystretch}{1.3}
\begin{center}
\begin{tabular}{||c||c||c||c||}\hline
Option & Values & Meaning & Default \\\hline\hline
\keyword{stress} & \keyword{moderate} & Low ingestion volume with occasional peaks & X \\\cline{2-4}
                 & \keyword{constant} & Constant ingestion of high volume          &   \\\cline{2-4}
                 & \keyword{insane} & Constant ingestion of very high volume       &   \\\hline\hline
\keyword{disk} & \keyword{hdd}  & Disk space is allocated in large chunks          & X \\\cline{2-4}
               & \keyword{ssd}  & Disk space is allocated in small chunks          &   \\\cline{2-4}
               & \keyword{raid} & Currently, no effect                             &   \\\hline\hline
\keyword{compression} & 'zstd'  & zstd is used for compression                     & X \\\cline{2-4}
                      & 'lz4'   & lz4 is used for compression (\comment{not available}) &   \\\cline{2-4}
                      & ''      & Data in this table are not compressed at all     &   \\\cline{1-4}
\end{tabular}
\end{center}
\egroup

The option \keyword{stress} affects the number of threads
allocated to perform ingestion tasks
like compression, sorting and indexing.
How many threads are allocated
is not part of this specification
and may vary between platforms.

The user may decide on the compression algorithm to use.
The standard compression algorithm is \term{zstd},
which is fast, but has also very good compression ratio.
It is recommended to use \term{zstd} in most cases.
\term{lz4} (\comment{not yet available}) is faster than \term{zstd},
in particular on decompression,
but has a weaker compression ratio.
Finally, no compression at all (empty string)
makes sense on small tables
that are known never to grow beyond some megabyte in size
(or beyond some million edges).

An example of a \term{create table} statement with options is

\keyword{create table} \identifier{mytable}
\keyword{set} \keyword{stress} = \keyword{constant},
              \keyword{compression} = 'zstd'

\subsubsection{DROP}
The \term{drop table} statement removes
an existing storage entity for edges
physically from disk.
It has the form:

\keyword{drop table} \identifier{mytable}

\subsubsection{ALTER}

\subsection{Type}
\term{Types} are user-defined types
stored as vertices in the database.
The syntax resembles very much
the \term{create table} syntax
in traditional \sql:

\keyword{create type} \identifier{product} \{ \\
\hspace*{1cm}\identifier{prod\_key} \keyword{uint} \keyword{primary key}, \\
\hspace*{1cm}\identifier{prod\_desc} \keyword{text}, \\
\hspace*{1cm}\identifier{prod\_price} \keyword{float} \\
\}

This creates a type called \term{product}
with three attributes:
\term{prod\_key}, \term{prod\_desc} and \term{prod\_price}.

There is no limit on the number of attributes
a type may have. Indeed, vertices with hundreds
of attributes are not uncommon.

Attributes may have any static type with one exception:
Each type needs a unique primary key and the field
that is primary key must be either
\keyword{uint} or \keyword{text}.

The order in which attributes are declared
determines the \term{canonical} order for this type.
The canonical order plays a role for the \term{insert}
statement.

\comment{
I am not happy with some of the design decisions
and the naming to be honest.
\term{Types} should be called \term{tables} and
what now is called \term{tables} should be called
\term{edgestore} or something like that.
Furthermore, there is this hidden thing \term{vertex}
that is felt in his impact, but (mostly) invisible.
In the future types (which, then, will be called tables),
will be stored per attribute (a.k.a. column)
and all the delicateness concerning
tables versus types and edges versus vertices
will go away just by itself.
}

\subsubsection{DROP}
The \term{drop type} statement removes a type
from the database. \comment{
At the moment, drop type removes only the type definition,
not the corresponding data;
in the future, that will certainly change.
}
It has the form:

\keyword{drop type} \identifier{product}

\subsection{Edge}
\subsubsection{CREATE}
The \term{create edge} statement defines the layout
of a specific edge type in the database.
Example:

\keyword{create edge} \identifier{buys} \{ \\
\hspace*{1cm} \keyword{origin} \identifier{client} \keyword{as} \identifier{client}, \\
\hspace*{1cm} \keyword{destin} \identifier{product} \keyword{as} \identifier{product}, \\
\hspace*{1cm} \keyword{label} \keyword{text}, \\
\hspace*{1cm} \keyword{weight} \keyword{int} \keyword{as} \identifier{quantity}, \\
\hspace*{1cm} \keyword{weight2} \keyword{float} \keyword{as} \identifier{paid} \\
\}

Edges have seven fields (in canonical order):
\keyword{edge},
\keyword{origin}, \keyword{destin},
\keyword{label}, \keyword{timestamp},
\keyword{weight} and \keyword{weight2}.

The type of the field `edge' is predefined.
It is always a string and corresponds to the
name of that edge (\eg\ `buys').
The reason that it exists at all
is that edges of different types can be stored
in the same table.
This makes especially sense for groups of edges
with few instances or for groups of edges
that are often read together.
Think for instance of \term{follow} and \term{unfollow}
in a social media application.
We might want to read \term{follow} and \term{unfollow}
events together ordered by timestamp to determine
what the current state is.

Likewise is the type of the timestamp predefined
and cannot change.

All other types can be defined.
The types of \keyword{origin} and \keyword{destin}
are usually \keyword{type}s, since they refer
to vertices which are connected by this specific edge.
Stored in the database is the value of the primary key
of the specific type (\ie\ \keyword{uint} for product).

But they also may have static types, namely
\keyword{uint} or \keyword{text}.

The field \keyword{label} as well may be of type
\keyword{uint} or \keyword{text}.

The fields \keyword{weight} and \keyword{weight2}
may have any static type.

Fields that are not mentioned in the edge definition
are invisible and cannot be used.

\comment{
Some aspects of the design are centred around the idea
that it should be possible to insert \textit{ad-hoc}
data, in particular edges,
that were not previously defined in terms of \acronym{ddl}.
More recent design decisions (like the one above)
foreclose this possibility.
This is still an ongoing design process and
some details may change...
}

It is also possible to rename edge fields
according to their real purpose in a concrete
application (\eg\ naming \keyword{weight} \identifier{quantity}).
All fields that may appear in an edge definition
may be renamed in this way.
\comment{Not yet available!}

\subsubsection{DROP}
The \term{drop edge} statement removes an edge definition,
but not the data described by this definition,
from the database.
It has the form:

\keyword{drop edge} \identifier{buys}

\subsection{Index}
\subsubsection{CREATE}
The \term{create index} statement
creates an index physically on disk.
It has the form:

\keyword{create index} \identifier{myidx} \keyword{on} \identifier{mytable}
(\identifier{field1}, \identifier{field2})

\comment{
It is possible to create indices on vertex.
But that is a mess and is not documented here.
In fact, currently, indices on vertex are
not on the user-defined attributes, but on
internal attributes
(like \term{roleid}, \term{property}, \etc).
That, obviously, does not make any sense.
Instead there will be internal indices
that are created, when the database is created,
and user-defined indices, which will then be
defined on the type attributes.
}

The fields (``field1'', ``field2'', \etc)
are edge fields. Any combination of fields
can be used in index definitions.
It is not recommended, however,
to create indices on fields that are defined as \keyword{float}
or \keyword{time} (\eg\ \keyword{timestamp}).

\comment{
There will be the possibility to define indices over ranges
of \keyword{float} fields and periods
of \keyword{time} fields. But that is not yet available.
}

The \keyword{index} keyword can be decorated with a sizing
indication, \eg:

\keyword{create tiny index} \identifier{myidx} \keyword{on} \identifier{mytable}
(\identifier{field1}, \identifier{field2})

The default sizing is \keyword{small}.

It rarely makes sense to create 
\keyword{big}, 
\keyword{large} or 
\keyword{huge} indices.
It actually makes sense,
when the index from the beginning
has many keys with many data points.
More details on this can be found in \ref{chpt_sizing}.

\subsubsection{DROP}
The \term{drop index} statement removes an index physically from disk.
Example:

\keyword{drop index} \identifier{myidx}

\subsection{Procedure}
\subsubsection{CREATE}
The \term{create procedure} statement
creates procedure interface in the database.
It has the form:

\keyword{create procedure} \identifier{mymodule}.\identifier{myfun}(
                           \identifier{param1} \keyword{uint},
                           \identifier{param2} \keyword{text})
                           \keyword{language} \identifier{python}

A procedure may have no parameters.
The definition then simplifies to

\keyword{create procedure} \identifier{mymodule}.\identifier{myfun}()
                           \keyword{language} \identifier{python}

Any number of parameters is allowed and parameters may have
any static type.

Known languages are \identifier{python} and \identifier{lua}.
\comment{Lua is not yet available.}

\subsubsection{DROP}
The \term{drop procedure} statement
drops a procedure interface from the database.
It has the form:

\keyword{drop procedure} \identifier{myfun}

\subsection{Function}
\comment{Not yet available}

\subsection{Period}
\term{Period} is not a \term{first-class citizens}
like types, edges, procedures, \etc\
In particular, periods cannot be created or altered.
They evolve as an effect of inserting edges into
the database. However, periods can be identified
and they can be dropped.

Dropping data according to timestamps is an important
feature in timeseries databases.
Without this feature, databases would grow
to an extent that would make efficient queries difficult
or even impossible. Deleting data by means of the
\term{delete} statement is not efficient for large
amounts of data. In the case of \nowdb\
(but also with other databases), deleting
the data would not solve the problem,
because \term{delete} does not physically remove
the data, but just makes them invisible.

Dropping, by contrast, removes all data files 
that contain only data belonging to that period.
Removing files, however, is a very efficient
operation on most platforms, since it only
declares the disk space free.

The syntax is:

\keyword{drop period on} \identifier{mytable} \\
\keyword{where timestamp} $\ge$ '2018-01-01' \\
\hspace*{0.45cm}\keyword{and timestamp} $<$  '2018-04-01'

This would drop all data files of table `mytable'
that contain data between Jan, 1, 2018 (inclusive) and
April, 1, 2018 (exclusive). 

Two remarks are in place. First,
\term{drop period} must have a \term{where} clause.
There must be at most two conditions in the \term{where} clause
and, if there are two, they must be connected by \keyword{and}.
All conditions must refer to \keyword{timestamp} and there
must be precisely one condition that
determines an \emph{end date}
for the period, \ie\ there must be a non-negated expression
that contains \keyword{timestamp} and a constant date
and one of the operations $<$ or $\le$.

The rationale for this restrictions is
to avoid accidentally dropping entire tables
using too complex or incomplete \term{drop} statements.
The keyword \keyword{between} is not used with \term{drop period}
because \keyword{between} makes constructions
without a start date somewhat artificial.
Furthermore, \keyword{between} does not allow
distinguishing between \emph{in}clusive and
\emph{ex}clusive selections of period limits.

To illustrate that, the following example 
is legal and it drops all data
before a given date (which is very common
for timeseries databases, that often represent gliding
time windows):

\keyword{drop period on} \identifier{mytable} \\
\keyword{where timestamp} $<$ '2018-04-01'

Second, \term{drop period} does not guarantee
to drop all data that lie in the period in question --
in fact, it does not even guarantee to drop any data at all.
It guarantees, however, to remove all files
that \emph{only} data that lie that period.
In other words, the behaviour is conservative
and prefers dropping less data than possible over
dropping too many data.
On the long run, however, with a consistent dropping policy
old data will by removed consistently and the database
won't grow (except when the periods themselves grow).

\section{Data Manipulation}
\subsection{Insert}
The \term{insert} statements inserts one or more rows
to a given table or type.
The basic form is

\keyword{insert into} \identifier{mytable} 
                      (\identifier{myfield1},
                       \identifier{myfield2})
                      (value1, value2)

A more concrete example is

\keyword{insert into} \identifier{product} 
                      (\identifier{prod\_key},
                       \identifier{prod\_desc},
                       \identifier{prod\_price})
                      (100001, 'Spinach', 1.99)

For an edge, this would be:

\keyword{insert into} \identifier{sales} 
                      (\keyword{edge},
                       \keyword{origin},
                       \keyword{destin},
                       \keyword{timestamp},
                       \keyword{weight},
                       \keyword{weight2})
                      (\\
                       'buys', 9000001, 100001,
                       '1929-01-22T08:53:22',
                       3, 5.97)

When the list of values insert is complete,
\ie\ covers all fields in the type or table,
and respects the canonical order,
a shortened form can be used, \eg:

\keyword{insert into} \identifier{product} 
                      (100001, 'Spinach', 1.99)

Note that for the shorthand form on edges,
all typeable edge fields must be declared
in the edge definition. 

It is also possible \comment{(not yet!)} to insert data from
a query, \eg:

\keyword{insert into} \identifier{sales} ( \\
                      \keyword{edge},
                      \keyword{origin},
                      \keyword{destin},
                      \keyword{timestamp},
                      \keyword{weight},
                      \keyword{weight2}) (\\
\hspace*{0.2cm}\keyword{select} 'buys', \keyword{origin}, 
                         \keyword{destin},
                         \keyword{timestamp},
                         \keyword{weight},
                         \keyword{weight2} \\
\hspace*{0.35cm}\keyword{from} \identifier{another\_table} \\
\hspace*{0.2cm}\keyword{where} $\dots$)

For details on the \term{where} clause,
please refer to the \acronym{dql} section.

\subsection{Update}
The \term{update} statement changes the values
of fields in rows in tables or types.
Its general form is

\keyword{update} \identifier{mytable} \\
\hspace*{0.7cm} \keyword{set} field = value,\\
\hspace*{0.7cm} \keyword{set} field = value \\
\hspace*{0.1cm} \keyword{where} $\dots$

For instance:

\keyword{update} \identifier{product} \\
\hspace*{0.7cm} \keyword{set} \identifier{prod\_price} = 1.89 \\
\hspace*{0.1cm}  \keyword{where} \identifier{prod\_key} = 100001

For details on the \term{where} clause,
please refer to the \acronym{dql} section.

\comment{update has still many unsolved issues.
For instance, when changing primary keys
and other indexed fields, we need to delete
that particular row from the index and add it
again with the new value.
That, however, is quite expensive.
It therefore may take still some time
to make update available :-(}

\subsection{Delete}
The \term{delete} statement eliminates single
data points from tables or types.
Its general form is

\keyword{delete from} \identifier{mytable} \keyword{where} $\dots$

A more concrete example:

\keyword{delete from} \identifier{product}
\keyword{where} \identifier{prod\_key = 100001}

For details on the \term{where} clause,
please refer to the \acronym{dql} section.

It is worth mentioning that delete
does not physically remove data from disk.
It marks the corresponding rows as deleted,
so they won't be selected by other statements.

\comment{delete still has bugs and is therefore not yet available :-(}

\section{Data Loading}

\section{Data Query}

\section{Miscellaneous}
\subsection{Use}
\subsection{Exec}
